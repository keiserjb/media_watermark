<?php

/**
 * Implements hook_permission().
 */
function media_watermark_permission() {
  return array(
    'flex2 media watermark control' => array(
      'title' => t('Control watermark'),
      'description' => t('Checkbox appear for controlling watermark at file uploading.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function media_watermark_menu() {
  $items = array();

  $items['admin/config/media/watermark'] = array(
    'title' => 'Media Watermark settings',
    'description' => 'Control how to apply watermark.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_watermark_edit_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/media_watermark_edit.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/media/watermark/all'] = array(
    'title' => 'Edit Watermarks',
    'description' => 'Edit watermarks',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_watermark_edit_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/media_watermark_edit.admin.inc',
    'weight' => 1,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/media/watermark/add'] = array(
    'title' => 'Add watermark',
    'description' => 'Add watermark.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_watermark_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/media_watermark_add.admin.inc',
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/config/media/watermark/edit/%'] = array(
    'title' => 'Add watermark',
    'description' => 'Add watermark.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_watermark_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/media_watermark_add.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/media/watermark/delete/%'] = array(
    'title' => 'Delete watermark',
    'description' => 'Delete watermark.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_watermark_delete_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/media_watermark_delete.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * function to get all watermarks array stored in db
 * @return array $result array of all stored watermarks
 */
function media_watermark_get_watermarks() {
  $result = db_query("select * from {media_watermark}");
  if (isset($result) && !empty($result)) {
    return $result->fetchAll(PDO::FETCH_ASSOC);
  }
}

/**
 * function to get watermark name
 * @param int|string $id watermark id
 * @return string $result watermark name
 */
function media_watermark_get_name($id) {
  $result = db_query('SELECT name FROM {media_watermark} WHERE wid = :wid', array(':wid' => $id));
  $result = $result->fetchObject();
  if (!empty($result)) {
    $result = $result->name;
    return $result;
  }
}

/**
 * function to get watermark object
 * @param int|string $id watermark id
 * @return object $result
 */
function media_watermark_get_watermark($id) {
  $result = db_query('SELECT * FROM {media_watermark} WHERE wid = :wid', array(':wid' => $id));
  $result = $result->fetchObject();
  if (!empty($result)) {
    return $result;
  }
}

/*
* Implement hook_form_alter() for IMCE file uploading forms.
*/
function media_watermark_form_alter(&$form, $form_state, $form_id) {
  if (in_array($form_id, array('file_entity_add_upload_multiple', 'file_entity_add_upload', 'media_add_upload'))) {
    $form['no_watermark'] = array(
      '#type' => 'checkbox',
      '#title' => t('No watermark'),
      '#default_value' => FALSE,
      '#weight' => -10,
    );
    $watermarks = media_watermark_get_watermarks();
    $names = media_watermark_prepare_names($watermarks);
    $images = media_watermark_prepare_images($watermarks);
    $form['watermarks_names'] = array(
      '#type' => 'select',
      '#options' => $names,
      '#description' => t('To edit watermark just click on its image'),
      '#weight' => -9,
    );
    $form['watermarks_images'] = array(
      '#type' => 'item',
      '#markup' => $images,
      '#weight' => -8,
    );
    $form['#attached']['js'] = array(
      drupal_get_path('module', 'media_watermark') . '/media_watermark.js',
    );
    array_unshift($form['#submit'], 'media_watermark_add_watermark');
  }
}

/**
 *
 */
function media_watermark_add_watermark(&$form, &$form_state) {
  watchdog('test', serialize($form_state['values']));
  if (!$form_state['values']['no_watermark']) {
    //uploaded file
	if(is_object($form_state['values']['upload'])) {
      $file_path = drupal_realpath($form_state['values']['upload']->uri);
      media_watermark_create_image($file_path, $form_state);
    }
    elseif(is_int($form_state['values']['upload'])) {
      $uploaded = file_load($form_state['values']['upload']);
      $file_path = drupal_realpath($uploaded->uri);
      media_watermark_create_image($file_path, $form_state);
    }
    else {
      foreach ($form_state['values']['upload'] as $key => $value) {
        $file_path = drupal_realpath($value['tmppath']);
        media_watermark_create_image($file_path, $form_state);
      }
    }
  }
}

/**
 * media_watermark_create_image()
 * function to create jpeg image file
 * @param string $file_path temporary path of uploaded file
 * @param array $form_state array of form state
 */
function media_watermark_create_image($file_path, $form_state) {
  $watermark_obj = db_query("SELECT * FROM {media_watermark} WHERE fid = :fid", array(':fid' => $form_state['values']['watermarks_names']));
  $watermark_obj = $watermark_obj->fetchObject();
  $watermark_file = file_load($watermark_obj->fid);
  $watermark_filepath = drupal_realpath($watermark_file->uri);
  $watermark = new _imce_watermark();
  $img = imagecreatefromjpeg($file_path);
  $watermark_img = imagecreatefrompng($watermark_filepath);
  $im = $watermark->create_watermark($img, $watermark_img, $watermark_obj);
  imagejpeg($im, $file_path, 80);
}

/** function media_watermark_prepare_names().
 * @param array $results
 * @return array
 */
function media_watermark_prepare_names($results) {
  $names = array();
  foreach ($results as $key => $value) {
    $names[$value['fid']] = $value['name'];
  }
  return $names;
}

/** function media_watermark_prepare_names().
 * @param array $results
 * @return array
 */
function media_watermark_prepare_images($results) {
  $images = '';
  foreach ($results as $key => $value) {
    $file = file_load($value['fid']);
    $image = theme('image_formatter', array(
      'item' => array(
        'uri' => $file->uri,
        'alt' => t('Edit'),
        'title' => t('Edit'),
      ),
      'path' => array(
        'path' => 'admin/config/media/watermark/edit/' . $value['wid'],
        'options' => array('html' => TRUE),
      ),
      'image_style' => 'media_watermark',
    ));
    $images .= '<div class="image-hidden" id="image-' . $value['fid'] . '">' . $image . '</div>';
  }
  return $images;
}

/*
 * This class taken from: http://www.devshed.com/c/a/PHP/Dynamic-Watermarking-with-PHP/
 */
class _imce_watermark {
  # given two images, return a blended watermarked image

  function create_watermark($main_img_obj, $watermark_img_obj, $watermark) {
    $alpha_level = $watermark->alpha;
    $alpha_level /= 100; # convert 0-100 (%) alpha to decimal
    # calculate our images dimensions
    $main_img_obj_w = imagesx($main_img_obj);
    $main_img_obj_h = imagesy($main_img_obj);
    $watermark_img_obj_w = imagesx($watermark_img_obj);
    $watermark_img_obj_h = imagesy($watermark_img_obj);

    $vm = $watermark->ver_margin;
    $hm = $watermark->hor_margin;
    switch ($watermark->hor_position) {
      case 'left':
        $main_img_obj_min_x = $hm;
        $main_img_obj_max_x = $watermark_img_obj_w + $hm;
        break;
      case 'middle':
        # determine center position coordinates
        $main_img_obj_min_x = floor(($main_img_obj_w / 2) - ($watermark_img_obj_w / 2)) + $hm;
        $main_img_obj_max_x = ceil(($main_img_obj_w / 2) + ($watermark_img_obj_w / 2)) + $hm;
        break;
      case 'right':
        $main_img_obj_min_x = $main_img_obj_w - $watermark_img_obj_w + $hm;
        $main_img_obj_max_x = $main_img_obj_w + $hm;
        break;
    }
    switch ($watermark->ver_position) {
      case 'top':
        $main_img_obj_min_y = $vm;
        $main_img_obj_max_y = $watermark_img_obj_h + $hm;
        break;
      case 'center':
        $main_img_obj_min_y = floor(($main_img_obj_h / 2) - ($watermark_img_obj_h / 2)) + $hm;
        $main_img_obj_max_y = ceil(($main_img_obj_h / 2) + ($watermark_img_obj_h / 2)) + $hm;
        break;
      case 'bottom':
        $main_img_obj_min_y = $main_img_obj_h - $watermark_img_obj_h + $vm;
        $main_img_obj_max_y = $main_img_obj_h + $hm;
        break;
    }

    # create new image to hold merged changes
    $return_img = imagecreatetruecolor($main_img_obj_w, $main_img_obj_h);

    # walk through main image
    for ($y = 0; $y < $main_img_obj_h; $y++) {
      for ($x = 0; $x < $main_img_obj_w; $x++) {
        $return_color = NULL;

        # determine the correct pixel location within our watermark
        $watermark_x = $x - $main_img_obj_min_x;
        $watermark_y = $y - $main_img_obj_min_y;

        # fetch color information for both of our images
        $main_rgb = imagecolorsforindex($main_img_obj, imagecolorat($main_img_obj, $x, $y));

        # if our watermark has a non-transparent value at this pixel intersection
        # and we're still within the bounds of the watermark image
        if ($watermark_x >= 0 && $watermark_x < $watermark_img_obj_w &&
          $watermark_y >= 0 && $watermark_y < $watermark_img_obj_h
        ) {
          $watermark_rbg = imagecolorsforindex($watermark_img_obj, imagecolorat($watermark_img_obj, $watermark_x, $watermark_y));

          # using image alpha, and user specified alpha, calculate average
          $watermark_alpha = round(((127 - $watermark_rbg['alpha']) / 127), 2);
          $watermark_alpha = $watermark_alpha * $alpha_level;

          # calculate the color 'average' between the two - taking into account the specified alpha level
          $avg_red = $this->_get_ave_color($main_rgb['red'], $watermark_rbg['red'], $watermark_alpha);
          $avg_green = $this->_get_ave_color($main_rgb['green'], $watermark_rbg['green'], $watermark_alpha);
          $avg_blue = $this->_get_ave_color($main_rgb['blue'], $watermark_rbg['blue'], $watermark_alpha);

          # calculate a color index value using the average RGB values we've determined
          $return_color = $this->_get_image_color($return_img, $avg_red, $avg_green, $avg_blue);

          # if we're not dealing with an average color here, then let's just copy over the main color
        }
        else {
          $return_color = imagecolorat($main_img_obj, $x, $y);
        } # END if watermark
        # draw the appropriate color onto the return image
        imagesetpixel($return_img, $x, $y, $return_color);
      } # END for each X pixel
    } # END for each Y pixel
    # return the resulting, watermarked image for display
    return $return_img;
  }

  # END create_watermark()
  # average two colors given an alpha

  function _get_ave_color($color_a, $color_b, $alpha_level) {
    return round((($color_a * (1 - $alpha_level)) + ($color_b * $alpha_level)));
  }

  # END _get_ave_color()
  # return closest pallette-color match for RGB values

  function _get_image_color($im, $r, $g, $b) {
    $c = imagecolorexact($im, $r, $g, $b);
    if ($c != -1) {
      return $c;
    }
    $c = imagecolorallocate($im, $r, $g, $b);
    if ($c != -1) {
      return $c;
    }
    return imagecolorclosest($im, $r, $g, $b);
  }

  # END _get_image_color()
}

# END watermark API